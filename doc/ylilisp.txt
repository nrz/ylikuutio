YliLisp is the scripting language of Ylikuutio.
YliLisp is influenced by Scheme, Common Lisp, Clojure,
C++, Java, AngelScript, Rust, and MATLAB.

Use cases:
* Defining physics simulations.
* Defining game scenes.
* In-simulation console.
* In-game console.
* NPC AI.
* Scripted game events.
* Game modding.

General features:
* Statically typed.
* Lexically scoped.
* Variables and functions in the same namespace (Lisp-1),
  like Scheme and Clojure.
* In addition to functions, there are function templates
  (generic functions).
* Both functions and function templates are first-class
  citizens.
* An identifier may refer to one of the following:
  * A variable.
  * A function.
  * A function template.
  * A built-in function (written in C++ and initialized for
    the context which is usually a `yli::ontology::Console`
    instance).
* Common function names follow names used by Scheme.
* All objects, both variables and functions,
  are `yli::ontology::Entity` entities.
* `yli::ontology::Entity` entities with global names
  are global YliLisp variables with the same name.
* YliLisp syntax follows Scheme syntax when possible
  considering other YliLisp design goals.

Conventions:
* Mutators marked with `!` like in Scheme, e.g. `set!`.
* Predicates marked with `?` like in Scheme, e.g. `null?`.

Numeric types:
* Test if variable is a number: `(number? 1)`         -> `#t`
* Test if variable is a number: `(number? 'foo)`      -> `#f`
* Test if variable is a number: `(number? '(1 2 3))`  -> `#f`
* Test if variable is a number: `(number? '#(1 2 3))` -> `#f`

Integer types:
* Statically typed: `(define my-number 'uint64 123)`.
* Without explicit type: `(define my-number 123)` is `uint64`.
* Without explicit type: `(define my-number 3.14)` is `double`.
* Type conversion must be explicit: `(as 'uint64 my-number)`.
* `cast` can only be used for converting into wider variables
  where the value always fits in the new type.
* When overflow, precision loss or truncation could occur
  `try-cast` needs to be used: `(try-as 'int8 my-number)`.
* If number does not fit in the type, `try-as` will throw.
* The default type for integer literals is `int64`.
* An integer literal that does not fit in `int64` causes
  a compiler error.
* Different types for integer literals for can be given:
  `'int64 123`.
* Integer variable types: `int8`, `int16`, `int32`, `int64`,
  `uint8`, `uint16`, `uint32`, `uint64`.
* Ylikuutio types:
  * `yli::lisp::Int8`
  * `yli::lisp::Uint8`
  * `yli::lisp::Int16`
  * `yli::lisp::Uint16`
  * `yli::lisp::Int32`
  * `yli::lisp::Uint32`
  * `yli::lisp::Int64`
  * `yli::lisp::Uint64`

Floating point types:
* `float`, `double`.
* Ylikuutio types:
  * `yli::lisp::Float`
  * `yli::lisp::Double`

Boolean types:
* `bool`.
* Ylikuutio type:
  * `yli::lisp::Bool`

Lists:
* List syntax: `(list 1 2 3)`.
* List syntax (syntactic sugar): `'(1 2 3)`.
* Test if variable is a list: `(list? 'foo)`      -> `#f`
* Test if variable is a list: `(list? '(1 2 3))`  -> `#t`
* Test if variable is a list: `(list? '#(1 2 3))` -> `#f`
* Ylikuutio type:
  * `yli::lisp::List`

Vectors:
* Row vector syntax: `(row-vector 1 2 3)`.
* Row vector syntax (syntactic sugar): `[1 2 3]`.
* Column vector syntax: `(column-vector 1 2 3)`.
* Column vector syntax (syntactic sugar): `{1 2 3}`.
* Test if variable is a vector: `(vector? 'foo)`      -> `#f`
* Test if variable is a vector: `(vector? '(1 2 3))`  -> `#f`
* Test if variable is a vector: `(vector? '#(1 2 3))` -> `#t`
* Test if variable is a row vector: `(row-vector? 'foo)`       -> `#f`
* Test if variable is a column vector: `(column-vector? 'foo)` -> `#f`
* Ylikuutio type:
  * `yli::lisp::Vector`

Matrices:
* Matrix is a datatype with a built-in support.
* `(matrix (number-of-rows-expr number-of-columns-expr cell-datatype))`
* Can be constructed from row vectors by using vertical concatenation:
  `{ [ 1 2 ] [ 3 4 ] }`
-> 1 2
   3 4
* Can be constructed from column vectors by using horizontal concatenation:
  `[ { 1 2 } { 3 4 } ]`
-> 1 3
   2 4

Structs:
* Struct syntax: `(struct foo)`.
* Member syntax: `(member (member foo 'bar) 'baz)`.
* Member syntax: `(member (member foo "bar") "baz")`.
* Struct syntax (syntactic sugar): `foo.bar.baz`
  (whitespace around dot operators is free).
* Generic setter can be used for struct members as well:
  `(set! (member foo bar) 123)`.
* Ylikuutio type:
  * `yli::lisp::Struct`

Parents and children:
* `(child (child foo 'bar) 'baz)`.
* `(child (child foo "bar") "baz")`.
* Syntactic sugar: `foo.bar.baz`

Masters and apprentices:
* `(apprentice (apprentice foo 'bar) 'baz)`.
* `(apprentice (apprentice foo "bar") "baz")`.
* Syntactic sugar: `foo:bar:baz`

Indexing:
* Indexing syntax: `(nth foo bar)`
* Indexing syntax (syntactic sugar): `foo[bar]`.
  (whitespace around square bracket operators is free).

Dynamically scoped variables:
* Syntax like is Scheme:
  * `(define pi 3.14)`
  * Dynamic variable definition in other Lisps:
    * Scheme:      `(define pi 3.14)`
    * Common Lisp: `(defparameter pi 3.14)`
    * Clojure:     `(def pi 3.14)`

Functions:
* Functions are non-generic thus the function signature
  must have type for all parameters (otherwise it will be
  a function template, see below).
* Functions are first-class citizens.
* Functions can be overloaded.
* Functions can have explicit return value type:
  * `(defun square ((x 'uint64)) 'uint64 (* x x))`
* Used `'void` for no return value.
  * `(defun square-but-return-void ((x 'uint64)) 'void (* x x))`
* Return type can be `auto` to be inferred automatically:
  * `(defun square ((x 'uint64)) 'auto (* x x))`
* Member functions/methods are supported as well:
  `(foo.bar)`, `(foo.bar baz)`, etc.
* Ylikuutio type:
  * `yli::lisp::LispFunction`

Function templates:
* If function signature lacks the type of one or more parameters
  or if it lacks the type of the return value, then that is
  a function template.
* Function template syntax:
  * `(defun square (x) 'auto (* x x))`
  * Consider function definition in other Lisps:
    * Scheme:      `(define (square x) (* x x))`
    * Common Lisp: `(defun square (x) (* x x))`
    * Clojure:     `(defn square [x] (* x x))`
* Function templates can have explicit parameter types
  for some of the parameters:
  * `(defun multiply ((x 'uint64) y) 'auto (* x y))`
* Function templates can have explicit return value type:
  * `(defun square (x) 'uint64 (* x x))`
* For function templates the actual function instantiation
  will be resolved in compile-time.
* There cannot be both a function and a function template
  in the same namespace with the same identifier.
* Ylikuutio type:
  * `yli::lisp::LispFunctionTemplate`

Pointers:
* `null` is a null pointer (like in Java).
* Dereferencing a null pointer causes an YliLisp exception.

Comments:
* `;` starts a comment until end of line.

Planned implementation details:
* Functions are `yli::ontology::LispFunction`,
  which inherits `yli::ontology::Entity`.
* Function overloads are implemented by a
  class template `yli::ontology::LispFunctionOverload`,
  which inherits `yli::ontology::GenericLispFunctionOverload`,
  a non-template class.
* Function templates are `yli::ontology::LispFunctionTemplate`,
  which inherits `yli::ontology::Entity`.
* `yli::ontology::GenericLispFunctionOverload` inherits
  `yli::ontology::Entity`.
* Lambda expressions are `yli::ontology::Lambda`,
  which inherits `yli::ontology::Entity`.
* Each `yli::ontology::Console` may register
  YliLisp functions into its local context,
  similarly to AngelScript.
* Ylikuutio does not use a C++ exception handler to handle
  exceptions triggered by execution of YliLisp code.

Command examples:
* `(define my-uint16 'uint64 123)`.
* `(define my-int32 (cast my-uint64 'int8))`.
* `(define my-uint64 'uint64 123)`.
* `(define my-int8 (try-cast my-uint64 'int8))`.
* `(define my-float 'float 3.14)`.
* `(define my-double (cast my-float 'double))`.

Links:
* https://compilers.iecc.com/crenshaw/
* https://craftinginterpreters.com/
