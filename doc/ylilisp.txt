YliLisp is the scripting language of Ylikuutio.
YliLisp is influenced by Scheme, Common Lisp, Clojure,
C++, Java, AngelScript, Rust, MATLAB, and Zig.

Use cases:
* Defining physics simulations.
* Defining game scenes.
* In-simulation console.
* In-game console.
* NPC AI.
* Scripted game events.
* Game modding.

General features:
* Statically typed.
* Lexically scoped.
* Variables and functions in the same namespace (Lisp-1),
  like Scheme and Clojure.
* In addition to functions, there are function templates
  (generic functions).
* Both functions and function templates are first-class
  citizens.
* Hygienic macros.
* Common function names follow names used by Scheme.
* All objects, both variables and functions,
  are `yli::ontology::Entity` entities.
* The set of built-in functions is defined by
  the execution context.
* `yli::ontology::Entity` entities with global names
  are global YliLisp variables with the same name.
* YliLisp syntax follows Scheme syntax when reasonable
  considering other YliLisp design goals.

Special characters:
* Comma `,` is whitespace just like space (Unicode 0x20) and
  Tab (Unicode 0x04), just like in Clojure.
* `?` prefix in type makes it optional, just like in Zig.
* `?` after type is a predicate function to check for the type.

Conventions:
* Mutators marked with `!` like in Scheme, e.g. `set!`.
* Predicates marked with `?` like in Scheme, e.g. `null?`.

Identifiers:
* An identifier may refer to one of the following:
  * A variable.
  * A function.
  * A function template.
  * A built-in function (written in C++ and initialized for
    the context which is usually a `yli::ontology::Console`
    instance).

Numeric types:
* Test if variable is a number: `(number? 1)`         -> `#t`
* Test if variable is a number: `(number? 'foo)`      -> `#f`
* Test if variable is a number: `(number? '(1 2 3))`  -> `#f`
* Test if variable is a number: `(number? '#(1 2 3))` -> `#f`

Integer types:
* Statically typed: `(define my-number 'uint64 123)`.
* Without explicit type: `(define my-number 123)` is `int64`.
* Without explicit type: `(define my-number 3.14)` is `double`.
* Type conversion must be explicit: `(as 'uint64 my-number)`.
* `as` can only be used for converting into wider variables
  where the value always fits in the new type.
* When overflow, precision loss or truncation could occur
  `try-as` needs to be used: `(try-as 'i8 my-number)`.
* If number does not fit in the type, `try-as` will throw.
* The default type for integer literals is `int64`.
* An integer literal that does not fit in `int64` causes
  a compiler error.
* Integer overflow causes an exception by default for both
  signed and unsigned types.
* Different types for integer literals for can be given:
  `'int64 123`.
* Integer variable types: `i8`, `i16`, `i32`, `i64`,
  `u8`, `u16`, `u32`, `u64`.
* Overflowing variable types: `oi8`, `oi16`, `oi32`, `oi64`,
  `ou8`, `ou16`, `ou32`, `ou64`.
* Ylikuutio types:
  * `yli::lisp::I8`
  * `yli::lisp::U8`
  * `yli::lisp::I6`
  * `yli::lisp::U16`
  * `yli::lisp::I32`
  * `yli::lisp::U32`
  * `yli::lisp::I64`
  * `yli::lisp::U64`

Floating point types:
* `f32`, `f64`.
* Ylikuutio types:
  * `yli::lisp::F32`
  * `yli::lisp::F64`

Complex number types:
* `(complex type-expr)`
  * Example: `(complex 'f64)`
* Syntactic sugar: `ci8`, `ci16`, `ci32`, `ci64`,
  `cu8`, `cu16`, `cu32`, `cu64`,
  `cf32`, `cf64`.
* Ylikuutio types:
  * `yli::lisp::CI8`
  * `yli::lisp::CU8`
  * `yli::lisp::CI16`
  * `yli::lisp::CU16`
  * `yli::lisp::CI32`
  * `yli::lisp::CU32`
  * `yli::lisp::CI64`
  * `yli::lisp::CU64`
  * `yli::lisp::CF32`
  * `yli::lisp::CF64`

Boolean types:
* `bool`.
* Values: `#t` (true), `#f` (false)
* Ylikuutio type:
  * `yli::lisp::Bool`

Lists:
* List syntax: `(list type-expr 1 2 3)`.
* Test if variable is a list: `(list? 'foo)`      -> `#f`
* Test if variable is a list: `(list? '(1 2 3))`  -> `#t`
* Test if variable is a list: `(list? '#(1 2 3))` -> `#f`
* Ylikuutio type:
  * `yli::lisp::List`

Vectors:
* Row vector syntax: `(row-vector type-expr 1 2 3)`.
  * Example: `(row-vector 'double 1 2 3)`.
* Column vector syntax: `(column-vector type-expr 1 2 3)`.
  * Example: `(column-vector 'double 1 2 3)`.
* Test if variable is a vector: `(vector? 'foo)`      -> `#f`
* Test if variable is a vector: `(vector? '(1 2 3))`  -> `#f`
* Test if variable is a vector: `(vector? '#(1 2 3))` -> `#t`
* Test if variable is a row vector: `(row-vector? 'foo)`       -> `#f`
* Test if variable is a column vector: `(column-vector? 'foo)` -> `#f`
* Ylikuutio type:
  * `yli::lisp::Vector`

Matrices:
* Matrix is a datatype with a built-in support.
* `(matrix type-expr matrix-data)`
  * Example: `(matrix 'f64 { [ 1 2 3 ]
                             [ 4 5 6 ]
                             [ 7 8 9 ] })
* Can be constructed from row vectors by using vertical concatenation:
  `{ [ 1 2 ] [ 3 4 ] }`
-> 1 2
   3 4
* Can be constructed from column vectors by using horizontal concatenation:
  `[ { 1 2 } { 3 4 } ]`
-> 1 3
   2 4

Structs:
* Struct syntax: `(struct foo)`.
* Member syntax: `(member (member foo 'bar) 'baz)`.
* Member syntax: `(member (member foo "bar") "baz")`.
* Struct syntax (syntactic sugar): `foo.bar.baz`
  (whitespace around dot operators is free).
* Generic setter can be used for struct members as well:
  `(set! (member foo bar) 123)`.
* Ylikuutio type:
  * `yli::lisp::Struct`

Parents and children:
* `(child (child foo 'bar) 'baz)`.
* `(child (child foo "bar") "baz")`.
* Syntactic sugar: `foo.bar.baz`

Masters and apprentices:
* `(apprentice (apprentice foo 'bar) 'baz)`.
* `(apprentice (apprentice foo "bar") "baz")`.
* Syntactic sugar: `foo:bar:baz`

Indexing:
* Indexing syntax: `(nth foo bar)`
* Indexing syntax (syntactic sugar): `foo[bar]`.
  (whitespace around square bracket operators is free).

Dynamically scoped variables:
* Syntax like is Scheme:
  * `(define pi 3.14)`
  * Dynamic variable definition in other Lisps:
    * Scheme:      `(define pi 3.14)`
    * Common Lisp: `(defparameter pi 3.14)`
    * Clojure:     `(def pi 3.14)`

Functions:
* Functions are non-generic thus the function signature
  must have type for all parameters (otherwise it will be
  a function template, see below).
* Functions are first-class citizens.
* Functions can be overloaded.
* Functions can have explicit return value type:
  * `(defun square ((x 'u64)) 'u64 (* x x))`
* Used `'void` for no return value.
  * `(defun square-but-return-void ((x 'u64)) 'void (* x x))`
* Return type can be `auto` to be inferred automatically:
  * `(defun square ((x 'u64)) 'auto (* x x))`
* Member functions/methods are supported as well:
  `(foo.bar)`, `(foo.bar baz)`, etc.
* Ylikuutio type:
  * `yli::lisp::LispFunction`

Function templates:
* If function signature lacks the type of one or more parameters
  or if it lacks the type of the return value, then that is
  a function template.
* Function template syntax:
  * `(defun square (x) 'auto (* x x))`
  * Consider function definition in other Lisps:
    * Scheme:      `(define (square x) (* x x))`
    * Common Lisp: `(defun square (x) (* x x))`
    * Clojure:     `(defn square [x] (* x x))`
* Function templates can have explicit parameter types
  for some of the parameters:
  * `(defun multiply ((x 'u64) y) 'auto (* x y))`
* Function templates can have explicit return value type:
  * `(defun square (x) 'u64 (* x x))`
* For function templates the actual function instantiation
  will be resolved in compile-time.
* There cannot be both a function and a function template
  in the same namespace with the same identifier.
* Ylikuutio type:
  * `yli::lisp::LispFunctionTemplate`

Pointers:
* `null` is a null pointer (like in Java).
* Dereferencing a null pointer causes an YliLisp exception.

Comments:
* `;` starts a comment until end of line.

Planned implementation details:
* Functions are `yli::ontology::LispFunction`,
  which inherits `yli::ontology::Entity`.
* Function overloads are implemented by a
  class template `yli::ontology::LispFunctionOverload`,
  which inherits `yli::ontology::GenericLispFunctionOverload`,
  a non-template class.
* Function templates are `yli::ontology::LispFunctionTemplate`,
  which inherits `yli::ontology::Entity`.
* `yli::ontology::GenericLispFunctionOverload` inherits
  `yli::ontology::Entity`.
* Lambda expressions are `yli::ontology::Lambda`,
  which inherits `yli::ontology::Entity`.
* Different execution contexts are `yli::ontology::Context`,
  and e.g. `yli::ontology::Console` inherits
  `yli::ontology::Context`.
* Each `yli::ontology::Context` may register built-in
  YliLisp functions into its local context,
  similarly to AngelScript.
* Each built-in must be registered to be able to be used.
  This enables creating precisely featured execution contexts.
  Common built-ins' registration snippets will be provided.
* Ylikuutio does not use a C++ exception handler to handle
  exceptions triggered by execution of YliLisp code.

Command examples:
* `(define my-uint16 'u16 123)`.
* `(define my-int32 (as 'i32 my-uint16))`.
* `(define my-uint64 'uint64 123)`.
* `(define my-int8 (try-as 'i8 my-uint64))`.
* `(define my-float 'f32 3.14)`.
* `(define my-double (as 'f64 my-float))`.

Links:
* https://compilers.iecc.com/crenshaw/
* https://craftinginterpreters.com/
