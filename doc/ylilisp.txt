YliLisp is the scripting language of Ylikuutio.
YliLisp is influenced by Scheme, Common Lisp, C++,
AngelScript, and Rust.

General features:
* Variables and functions in the same namespace (Lisp-1).
* Mutators marked with `!` like in Scheme, e.g. `set!`.
* Predicates marked with `?` like in Scheme, e.g. `null?`.
* Common function names follow names used by Scheme.
* All objects, both variables and functions,
  are `yli::ontology::Entity` entities.
* All named `yli::ontology::Entity` entities
  are YliLisp variables.
* YliLisp syntax follows Scheme syntax when possible
  considering other YliLisp design goals.

Integer types:
* The default type for integer literals is `int32`.
* Integer variable types: `int8`, `int16`, `int32`, `int64`,
  `uint8`, `uint16`, `uint32`, `uint64`.
* Statically typed: `(define my-number 'uint64 123)`.
* Type conversion must be explicit: `(cast my-number 'uint64)`.
* `cast` can only be used for converting into wider variables
  where the value always fits in the new type.
* When overflow, precision loss or truncation could occur
  `try-cast` needs to be used: `(try-cast my-number 'int8)`.
* If number does not fit in the type, `try-cast` will throw.

Floating point types:
* `float`, `double`.

Boolean types:
* `bool`.

Structs:
* Struct syntax: `(struct foo)`.
* Member syntax: `(member (member foo bar) baz)`.
* Struct syntax (syntactic sugar): `foo.bar.baz`
  (whitespace around dot operators is free).
* Generic setter can be used for struct members as well:
  `(set! (member foo bar) 123)`.

Vectors:
* Vector syntax: `(vector foo)`.

Indexing:
* Indexing syntax: `(nth foo bar)`
* Indexing syntax (syntactic sugar): `foo[bar]`.
  (whitespace around square bracket operators is free).

Functions:
* Functions can be overloaded.
* Member functions/methods are supported as well:
  `(foo.bar)`, `(foo.bar baz)`, etc.

Pointers:
* `nullptr` is a null pointer.

Comments:
* `;` starts a comment until end of line.
* `//` also starts a comment until end of line.
* `/*` ... `*/` can be used for block comments.

Planned implementation details:
* Functions are `yli::ontology::LispFunction`,
  which inherits `yli::ontology::Entity`.
* Function overloads are implemented by a
  class template `yli::ontology::LispFunctionOverload`,
  which inherits `yli::ontology::GenericLispFunctionOverload`,
  a non-template class.
* `yli::ontology::GenericLispFunctionOverload` inherits
  `yli::ontology::Entity`.
* Lambda expressions are `yli::ontology::Lambda`,
  which inherits `yli::ontology::Entity`.
* S-expressions are `yli::ontology::Sexp`,
  which inherits `yli::ontology::Entity`.
* Each `yli::ontology::Console` may register
  YliLisp functions into its local context,
  similarly to AngelScript.
* All variables are always available in all contexts.
* Ylikuutio uses a C++ exception handler to handle
  exceptions triggered by execution of YliLisp code.
* When an exception occurs, the effects caused by already
  executed YliLisp code are undone by setting and
  activating the old values stored on each change.

Command examples:
* `(define my-uint16 'uint64 123)`.
* `(define my-int32 (cast my-uint64 'int8))`.
* `(define my-uint64 'uint64 123)`.
* `(define my-int8 (try-cast my-uint64 'int8))`.
* `(define my-float 'float 3.14)`.
* `(define my-double (cast my-float 'double))`.

Links:
* https://compilers.iecc.com/crenshaw/
