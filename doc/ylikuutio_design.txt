Ylikuutio design

Ylikuutio supports different kinds of 3D games and simulations.

The main supported genres are 3D action adventures
and turn-based 3D strategy games, specifically
simultaneously executed and clock-based turns.

Hirvi is a first person action-adventure of the adventures of
a moose/elk called Hirvi. Work in progress.

Tulevaisuus ("the future" in Finnish) is a turn-based
3D tactical combat game with programmable robots.
Work in progress.

code/ajokki/                    - Ajokki sandbox code.
code/angelscript/               - AngelScript test code.
code/bash/                      - scripts written in Bash.
code/edit/                      - YliEdit editor code.
code/gpgpu_test/                - GPGPU test code.
code/hirvi/                     - Hirvi game code.
code/python/                    - scripts written in Python.
code/tulevaisuus/               - Tulevaisuus game code.
code/ylikuutio                  - Ylikuutio code.
code/ylikuutio/angelscript/     - AngelScript related code. See below for more detailed description about AngelScript-related code.
code/ylikuutio/audio/           - audio code. See below for more detailed description about audio.
code/ylikuutio/callback_system/ - callback functionality.
code/ylikuutio/command_line/    - command line argument processing.
code/ylikuutio/common/          - `AnyValue` & `AnyStruct` data structures.
code/ylikuutio/config/          - `SettingMaster` & `Setting` classes used both for global and `Entity`-specific settings.
code/ylikuutio/console/         - code related to Ylikuutio console, except `Console` itself, which is `Entity` and located in `ontology` with other Entities.
code/ylikuutio/file/            - file loading and writing code.
code/ylikuutio/geometry/        - geometry-related code.
code/ylikuutio/graph/           - graph-related code.
code/ylikuutio/hierarchy/       - class hierachy related code.
code/ylikuutio/input/           - input device related code.
code/ylikuutio/interpolation/   - interpolation code.
code/ylikuutio/linear_algebra/  - code related to `Matrix` & `Tensor3` classes used for linear algebra.
code/ylikuutio/load/            - asset loading code. See below for more detailed description about asset loading.
code/ylikuutio/log/             - logging related code.
code/ylikuutio/map/             - code related to `std::map` & `std::unordered_map`.
code/ylikuutio/memory/          - memory related code.
code/ylikuutio/network/         - network related code.
code/ylikuutio/ontology/        - ontology related code. See below for more detailed description about Ylikuutio ontology.
code/ylikuutio/opengl/          - OpenGL related code.
code/ylikuutio/sdl/             - SDL related code.
code/ylikuutio/shaders/         - GLSL shaders.
code/ylikuutio/snippets/        - code snippets that can be used in different applications which use Ylikuutio.
code/ylikuutio/string/          - string processing code.
code/ylikuutio/tests/           - unit tests.
code/ylikuutio/time/            - time related code.
code/ylikuutio/triangulation/   - triangulation related code. See below for more detailed description about triangulation.

code/ylikuutio/angelscript/

`AngelscriptMaster` is the master class of Ylikuutio AngelScript functionality.

code/ylikuutio/audio/

`AudioMaster` is the master class of Ylikuutio audio. It is created by the `Universe` and it's lifetime ends when `Universe` is destroyed.

code/ylikuutio/load/

In Ylikuutio asset loading is implemented using 3 kinds of functions:
1. file format specific functions.
2. file format and asset type specific functions.
3. asset type specific functions.

1. File format specific functions read the data from the file and store some relevant values into reference variables
and return the data as is as a `std::shared_ptr<std::vector<T>>`, where `T` is usually `uint8_t`, but e.g. if
all the data are e.g. `int32_t`, then `std::shared_ptr<std::vector<int32_t>>` shall be used instead as return type.
Example: `yli::load::load_BMP_file`.

2. File format and asset type specific functions receive the data from the file format specific functions and
convert the data into data structures that are generic to the asset type and are not specific to the file format.
Example: `yli::load::load_BMP_terrain`.

3. Asset type specific functions get the data from the file format and asset type specific functions (converted into
data structures that are generic to the asset type and not specific to the file format) and process the data and
create the actual assets, which are usually some `yli::ontology::Entity` objects (specific descendant class depends on
the asset type).
Example: `yli::load::load_Species`.

Some asset loading functions do not yet follow the model-view-adapter software architectural pattern described above.

code/ylikuutio/ontology/

In Ylikuutio, ontology is a broad collection of classes which inherit `Entity` either directly or indirectly.
Ontology classes form an ontological hierarchy that is based on composition. The top-level class of the hierarchy
is `Universe`.

In `ontology` namespace and directory there are also classes `ParentModule` and `ChildModule`.
`ParentModule` and `ChildModule` do not inherit `Entity`. They are anyway in `ontology` directory and namespace
because they are modules to be used in different `ontology` classes. They are modules that can be used to
provide standard functions needed for binding in composition relationships between ontology classes.
For special binding needs, e.g. when the children need to be in a specific order, custom code should be used
instead of `ParentModule`, `ChildModule`, or both.

In `ontology` namespace and directory there are also classes used for passing parameters to constructors of
`ontology` classes. These classes include `UniverseStruct`, `SceneStruct`, `ShaderStruct`, `MaterialStruct`,
`SpeciesStruct`, `ObjectStruct`, `SymbiosisStruct`, `HolobiontStruct`, `BiontStruct`, `ComputeTaskStruct`,
`ShapeshifterSequenceStruct`. The class name relates directly to the class where it is used. However, some
of these classes used for passing parameters are used for more than 1 class. For example, `MaterialStruct` is
used as input for the constructors of `Material` and `SymbiontMaterial`, and `SpeciesStruct` is used as input
for the constructors of `Species`, `SymbiontSpecies`, `ShapeshifterTransformation`, and `ShapeshifterForm`.

Below are listed the ontology classes of Ylikuutio.
These should be in the canonical class order defined in `yli::common::Datatype`.

There are different hierarchical paths of ontology:

'entity' path:

`Entity` is the class that all other `yli::ontology` classes inherit either directly or indirectly.

'movable' path:

`Movable` is a class that all moving Entities such as animals, vehicles, cameras etc. inherit. `Movable` itself inherits `Entity`.

'simple' path:

`Universe` is the top-level class in `ontology` hierarchy. The instances of all other `ontology` classes are normally descendants of `Universe` instance.
`World` is a class between `Universe` and 1 or more `Scene`s and can be used for sharing hierarchically lower-level classes between different `Scene`s.
`Scene` is a location in the game or simulation world.
`Shader` is a the owner of GLSL shaders (vertex shaders and fragment shaders).
`Material` is the owner a texture.
`Species` is the owner of a mesh.
`Object` is a single object instance in a `Scene`.

'symbiont' path:

`Universe` (see above).
`World` (see above).
`Scene` (see above).
`Shader` (see above).
`Symbiosis` is a class that owns `SymbiontMaterial`s and `SymbiontSpecies`.
`SymbiontMaterial` is a `Material` owned by a `Symbiosis`.
`SymbiontSpecies` is a `Species` owned by a `Symbiosis`.

'holobiont' path:

`Universe` (see above).
`World` (see above).
`Scene` (see above).
`Shader` (see above).
`Symbiosis` (see above).
`Holobiont` is a single instance of a `Symbiosis`. Each `Holobiont` is a symbiotic organism and consists of 1 or more `Biont`s.
`Biont` is a symbiont belonging to a specific `Holobiont`.

'text 2D' path:
`Universe` (see above).
`Font2D` is a class that owns a single 2D font.
`Text2D` is a class that owns a single 2D text written in the 2D font.

'text 3D' path:
`Universe` (see above).
`World` (see above).
`Scene` (see above).
`Shader` (see above).
`Material` (see above).
`VectorFont` is class that owns a the `Glyph`s of a single vector font, and also `Text3D` entities.
`Glyph` is a single glyph belonging to the vector font.
`Text3D` is a class that owns a single vector graphics text written using the vector font.

'console' path:
`Universe` (see above).
`Console` is a class that provides in-app console that can be either in the main view or in the future also inside a `Scene`.

'compute' path:
`Universe` (see above).
`World` (see above).
`Scene` (see above).
`Shader` (see above).
`ComputeTask` is a class that owns the data used for GPGPU computation using the GLSL vertex shader and GLSL fragment shader owned by the `Shader`.

Triangulation

Height maps are usually provided as a 2D grid. As Ylikuutio uses only triangles, the 2D grid needs to be triangulated.

About the ontological hierarchy

As described above, `yli::ontology` contains many classes that are in a compositional part-of-relationship (in Ylikuutio terminology, parts are 'children' and the Entities they belong are their 'parents'). Being a parent is called 'parenting' and being a child is called 'childing'.

Naturally, children must be bound to their parents somehow. There are different options for different parent-child-relationships:

1. Parent is `yli::ontology::Entity`. This is quite complex case. Children include `yli::ontology::Setting` and `yli::ontology::AnyStructEntity`.
2. Parent uses `yli::ontology::ParentModule` for 'parenting' and child used `yli::ontology::ChildModule` for 'childing'.
   Use this when possible. Constructor of `ChildModule` does the binding and destructor of `ChildModule` does the unbinding.
3. Parent uses `yli::ontology::ParentModule` for 'parenting' and child uses custom code for 'childing'.
   Custom code does the binding and unbinding, using `ParentModule` interface, just like `ChildModule` does.
4. Parent uses custom code for parenting and child uses custom code for 'childing'. see `Scene`-`Shader`-relationship for an example.
   The reason to use custom binding code in `Scene`-`Shader`-relationship is to keep `Shader`s ordered in `ShaderPriorityQueue`.
   In this case binding is completely custom for both 'parenting' and 'childing'. Use this only as a last resort.
